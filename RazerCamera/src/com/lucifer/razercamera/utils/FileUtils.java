package com.lucifer.razercamera.utils;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.StringReader;import java.io.StringWriter;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.net.Uri;import android.os.Environment;import android.os.StatFs;public class FileUtils{		private FileUtils()      {          /* cannot be instantiated */          throw new UnsupportedOperationException("cannot be instantiated");      }  			//SDCard	    /**      * 判断SDCard是否可用      *       * @return      */      public static boolean isSDCardEnable()      {          return Environment.getExternalStorageState().equals(                  Environment.MEDIA_MOUNTED);      }            /**      * 获取SD卡路径      *       * @return      */      public static String getSDCardPath()      {          return Environment.getExternalStorageDirectory().getAbsolutePath()                  + File.separator;      }            /**      * 获取SD卡的剩余容量 单位byte      *       * @return      */      public static long getSDCardAllSize()      {          if (isSDCardEnable())          {              StatFs stat = new StatFs(getSDCardPath());              // 获取空闲的数据块的数量              long availableBlocks = (long) stat.getAvailableBlocks() - 4;              // 获取单个数据块的大小（byte）              long freeBlocks = stat.getAvailableBlocks();              return freeBlocks * availableBlocks;          }          return 0;      }              /**      * 获取指定路径所在空间的剩余可用容量字节数，单位byte      *       * @param filePath      * @return 容量字节 SDCard可用空间，内部存储可用空间      */      public static long getFreeBytes(String filePath)      {          // 如果是sd卡的下的路径，则获取sd卡可用容量          if (filePath.startsWith(getSDCardPath()))          {              filePath = getSDCardPath();          } else          {// 如果是内部存储的路径，则获取内存存储的可用容量              filePath = Environment.getDataDirectory().getAbsolutePath();          }          StatFs stat = new StatFs(filePath);          long availableBlocks = (long) stat.getAvailableBlocks() - 4;          return stat.getBlockSize() * availableBlocks;      }            /**     * 使用这个方法需要写外部存储的权限“<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />”，     * 调用该方法会返回应用程序的外部文件系统（Environment.getExternalStorageDirectory()）目录的绝对路径，它是用来存放应用的缓存文件，     * 它和getCacheDir目录一样，目录下的文件都会在程序被卸载的时候被清除掉。      */    public static File getSDCardCache(Context context)      {          if (isSDCardEnable())          {          	return context.getExternalCacheDir();        }          return null;      }                  /**      * 获取系统存储路径      *       * @return      */      public static String getRootDirectoryPath()      {          return Environment.getRootDirectory().getAbsolutePath();      }                  /**     * 返回通过Context.openFileOutput()创建和存储的文件系统的绝对路径，应用程序文件，     * 这些文件会在程序被卸载的时候全部删掉。     */    public static File getAppFile(Context context)    {    	return context.getFilesDir();    }            /**     * 返回应用程序指定的缓存目录，这些文件在设备内存不足时会优先被删除掉，     * 所以存放在这里的文件是没有任何保障的，可能会随时丢掉。     */    public static File getAppCache(Context context)    {    	return context.getCacheDir();    }            /**     * 这是一个可以存放你自己应用程序自定义的文件，你可以通过该方法返回的File实例来创建或者访问这个目录，     * 注意该目录下的文件只有你自己的程序可以访问。     */    public static File getAppDir(Context context, String path)    {    	return context.getDir(path, 0);    }                    //File    	/**	 * 在SD卡上创建文件	 * 	 * @param fileName	 * @return	 * @throws IOException	 */	public File createSDFile(String fileName) throws IOException	{		File file = new File(fileName);		file.createNewFile();		return file;	}		/**	 * 在SD卡上创建目录	 * 	 * @param dirName	 * @return	 */	public File createSDDir(String dirName)	{		File dir = new File(dirName);		dir.mkdir();		return dir;	}		/**	 * 判断SD卡上的文件夹是否存在	 * 	 * @param fileName	 * @return	 */	public boolean isFileExist(String fileName)	{		File file = new File(fileName);		return file.exists();	}		/**	 * 将一个InputStream里面的数据写入到SD卡中	 * 	 * @param path	 * @param fileName	 * @param input	 * @return	 */	public File write2SDFromInput(String path, String fileName, InputStream input)	{		int FILESIZE = 4 * 1024;				File file = null;		OutputStream output = null;		try		{			createSDDir(path);			file = createSDFile(path + fileName);			output = new FileOutputStream(file);			byte[] buffer = new byte[FILESIZE];			/*			 * 真机测试，这段可能有问题，请采用下面网友提供的 while((input.read(buffer)) != -1){			 * output.write(buffer); }			 */			/* 网友提供 begin */			int length;			while ((length = (input.read(buffer))) > 0)			{				output.write(buffer, 0, length);			}			/* 网友提供 end */			output.flush();		} catch (Exception e)		{			e.printStackTrace();		} finally		{			try			{				output.close();			} catch (IOException e)			{				e.printStackTrace();			}		}		return file;	}    			//File与各种形式的转化			//将字符串写入指定文件(当指定的父路径中文件夹不存在时，会最大限度去创建，以保证保存成功！) 	 public static boolean string2File(String res, String filePath) 	 {         boolean flag = true;         BufferedReader bufferedReader = null;         BufferedWriter bufferedWriter = null;         try          {             File distFile = new File(filePath);             if (!distFile.getParentFile().exists()) distFile.getParentFile().mkdirs();             bufferedReader = new BufferedReader(new StringReader(res));             bufferedWriter = new BufferedWriter(new FileWriter(distFile));             char buf[] = new char[1024];         //字符缓冲区             int len;             while ((len = bufferedReader.read(buf)) != -1)              {                     bufferedWriter.write(buf, 0, len);             }             bufferedWriter.flush();             bufferedReader.close();             bufferedWriter.close();         }          catch (IOException e)          {             e.printStackTrace();             flag = false;             return flag;         }          finally          {             if (bufferedReader != null)              {                 try                  {                         bufferedReader.close();                 }                  catch (IOException e)                  {                         e.printStackTrace();                 }             }         }         return flag; }	 	 	 /**      * 文本文件转换为指定编码的字符串      *      * @param file         文本文件      * @param encoding 编码类型      * @return 转换后的字符串      * @throws IOException      */     public static String file2String(File file, String encoding)      {		InputStreamReader reader = null;		StringWriter writer = new StringWriter();		try		{			if (encoding == null || "".equals(encoding.trim()))			{				reader = new InputStreamReader(new FileInputStream(file),						encoding);			} else			{				reader = new InputStreamReader(new FileInputStream(file));			}			// 将输入流写入输出流			char[] buffer = new char[1024];			int n = 0;			while (-1 != (n = reader.read(buffer)))			{				writer.write(buffer, 0, n);			}		} catch (Exception e)		{			e.printStackTrace();			return null;		} finally		{			if (reader != null)			{				try				{					reader.close();				} catch (IOException e)				{					e.printStackTrace();				}			}		}		// 返回转换结果		if (writer != null)			return writer.toString();		else			return null;	}     	/**	 * 获得指定文件的byte数组	 */	public static byte[] getBytes(String filePath)	{		byte[] buffer = null;		try		{			File file = new File(filePath);			FileInputStream fis = new FileInputStream(file);			ByteArrayOutputStream bos = new ByteArrayOutputStream(1000);			byte[] b = new byte[1000];			int n;			while ((n = fis.read(b)) != -1)			{				bos.write(b, 0, n);			}			fis.close();			bos.close();			buffer = bos.toByteArray();		} catch (FileNotFoundException e)		{			e.printStackTrace();		} catch (IOException e)		{			e.printStackTrace();		}		return buffer;	}			/**	 * 根据byte数组，生成文件	 */	public static void getFile(byte[] bfile, String filePath, String fileName)	{		BufferedOutputStream bos = null;		FileOutputStream fos = null;		File file = null;		try		{			File dir = new File(filePath);			if (!dir.exists() && dir.isDirectory())			{// 判断文件目录是否存在				dir.mkdirs();			}			file = new File(filePath + "\\" + fileName);			fos = new FileOutputStream(file);			bos = new BufferedOutputStream(fos);			bos.write(bfile);		} catch (Exception e)		{			e.printStackTrace();		} finally		{			if (bos != null)			{				try				{					bos.close();				} catch (IOException e1)				{					e1.printStackTrace();				}			}			if (fos != null)			{				try				{					fos.close();				} catch (IOException e1)				{					e1.printStackTrace();				}			}		}	}		//二进制转字符串	public static String byte2hex(byte[] b) throws FileNotFoundException	{		StringBuffer sb = new StringBuffer();		String stmp = "";		for (int n = 0; n < b.length; n++)		{			stmp = Integer.toHexString(b[n] & 0XFF);			if (stmp.length() == 1)			{				sb.append("0" + stmp);			} else			{				sb.append(stmp);			}		}		return sb.toString();	}			}