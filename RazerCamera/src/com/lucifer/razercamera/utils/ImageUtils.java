package com.lucifer.razercamera.utils;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;import java.util.ArrayList;import com.lucifer.razercamera.common.AppContext;import android.annotation.TargetApi;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.ColorMatrix;import android.graphics.ColorMatrixColorFilter;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.Paint.FontMetrics;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.RectF;import android.graphics.Bitmap.Config;import android.graphics.PorterDuff.Mode;import android.graphics.Typeface;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.media.ThumbnailUtils;import android.net.Uri;import android.os.Build;import android.os.Environment;import android.util.Base64;import android.util.DisplayMetrics;import android.util.Log;import android.widget.ImageView;import android.widget.Toast;@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)public class ImageUtils{	public static final int LEFT = 0;	public static final int RIGHT = 1;	public static final int TOP = 3;	public static final int BOTTOM = 4;	public static String bitNametime;				//获取和保存图片	//保存图片	public static void compressBmpToFile(Bitmap bmp, File file)	{	    ByteArrayOutputStream baos = new ByteArrayOutputStream();	    int options = 80;//个人喜欢从80开始	    bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);	    while (baos.toByteArray().length / 1024 > 100) 	    { 	      baos.reset();	      options -= 10;	      bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);	    }	    try 	    {	      FileOutputStream fos = new FileOutputStream(file);	      fos.write(baos.toByteArray());	      fos.flush();	      fos.close();	    } 	    catch (Exception e) 	    {	      e.printStackTrace();	    }	  }				public static void saveBitmap(Bitmap bitmap, String path, String fileName, int quality)	{		File dirFile = new File(path);		if (!dirFile.exists())		{			dirFile.mkdirs();		}		try		{			File myCaptureFile = new File(dirFile + File.separator + fileName);			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(myCaptureFile));						bitmap.compress(Bitmap.CompressFormat.JPEG, quality, bos);			bitmap.recycle();						bos.flush();			bos.close();		} 		catch (FileNotFoundException e)		{			e.printStackTrace();		} 		catch (IOException e)		{			e.printStackTrace();		}	}				//获取图像	public static Drawable getDrawableFromUrl(String pathUrl)	{		URL url = null;		InputStream isInputStream = null;		try		{			url = new URL(pathUrl);			URLConnection connection = url.openConnection();			isInputStream = connection.getInputStream();		} 		catch (Exception e)		{			e.printStackTrace();		}		Bitmap bitmap = BitmapFactory.decodeStream(isInputStream);		@SuppressWarnings("deprecation")		BitmapDrawable drawable = new BitmapDrawable(bitmap);		return drawable;	}			//从指定路径获取图片。过程应该是：用流去获取图像，避免大图加载进来导致OOM，然后计算Options，再根据计算的大小		//获取能接受的图片大小，然后用自己的参数加载图片进来。然后可以再继续做压缩处理。		//？？？？？？问题就是如何动态获取图片的大小，下面的压缩方法不能获取图片的动态大小。		public static Bitmap getImageFromLocal(String imagePath) 		{			Bitmap bitmap = null;			BitmapFactory.Options options = new BitmapFactory.Options();						//如果图片质量大于400kb，会压缩一半。否则，加载原图。			File file = new File(imagePath);			long size = file.length();			long bi = size / (200 * 1024);			double bigen = Math.sqrt(bi);			int bigenzheng = (int) Math.abs(bigen);						options.inSampleSize = bigenzheng;						try 			{				bitmap = BitmapFactory.decodeFile(imagePath, options);			} 			catch (OutOfMemoryError e1) 			{				return null;			} 			catch (Exception ooe) 			{				return null;			}						//如果图片的长、宽大于指定长宽，则强制大小；否则用原图			int screenWidth = AppContext.getScreenWidth();			int screenHeight = AppContext.getScreenHeight();						int otherHeight = AppContext.dip2px(180);			int flHeight = screenHeight - otherHeight;						int bitmapRealWidth = 0;			int bitmapRealHeight = 0;						if(bitmap.getWidth() > screenWidth || bitmap.getHeight() > flHeight)			{				float widthScale = bitmap.getWidth()/screenWidth;				float heightScale = bitmap.getHeight()/flHeight;				if(widthScale > heightScale)				{					bitmapRealWidth = screenWidth;					bitmapRealHeight = bitmapRealWidth * bitmap.getHeight() / bitmap.getWidth();				}				else 				{					bitmapRealHeight = flHeight;					bitmapRealWidth = bitmapRealHeight * bitmap.getWidth() / bitmap.getHeight();				}								bitmap = zoomBitmap(bitmap, bitmapRealWidth, bitmapRealHeight);			}									return bitmap;					}					public static Bitmap getVideoThumbnail(String videoPath, int width, int height, int kind)	{		Bitmap bitmap = null;		bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, kind);		System.out.println("w" + bitmap.getWidth());		System.out.println("h" + bitmap.getHeight());		bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height,		ThumbnailUtils.OPTIONS_RECYCLE_INPUT);		return bitmap;	}						//图像大小和质量处理		//图像压缩到指定质量大小，xxxK	//图片质量压缩	public static Bitmap compressImage(Bitmap image, int fileCount) 	{  		/*Bitmap result = null;				ByteArrayOutputStream out = new ByteArrayOutputStream();        image.compress(Bitmap.CompressFormat.JPEG, 80, out);        float zoom = (float)Math.sqrt(100 * 1024 / (float)out.toByteArray().length);        Matrix matrix = new Matrix();        matrix.setScale(zoom, zoom);        try		{        	result = Bitmap.createBitmap(image, 0, 0, image.getWidth(), image.getHeight(), matrix, true);		} catch (Exception e)		{			// TODO: handle exception			result = Bitmap.createBitmap(image, 0, 0, image.getWidth()/2, image.getHeight()/2, matrix, true);		}                out.reset();        result.compress(Bitmap.CompressFormat.JPEG, 80, out);        while(out.toByteArray().length > fileCount * 1024)        {            matrix.setScale(0.6f, 0.6f);            result = Bitmap.createBitmap(result, 0, 0, result.getWidth(), result.getHeight(), matrix, true);            out.reset();            result.compress(Bitmap.CompressFormat.JPEG, 50, out);        }                 return result;  */						ByteArrayOutputStream baos = new ByteArrayOutputStream();          image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中          int options = 100;          while (baos.toByteArray().length / 1024>100)         {  //循环判断如果压缩后图片是否大于100kb,大于继续压缩。很傻很天真，这个toByteArray根本不能返回真的图像大小。            baos.reset();//重置baos即清空baos              image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中              options -= 10;//每次都减少10          }          ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中          Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片          return bitmap;      }  		//计算图片的缩放比	public static int calculateInSampleSize(BitmapFactory.Options options,			int reqWidth, int reqHeight)	{		final int height = options.outHeight;		final int width = options.outWidth;		int inSampleSize = 1;		if (height > reqHeight || width > reqWidth)		{			final int heightRatio = Math.round((float) height					/ (float) reqHeight);			final int widthRatio = Math.round((float) width / (float) reqWidth);			inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;		}		return inSampleSize;	}				//将图像等比例缩放到指定大小，得到缩略图	public Bitmap getThumbnailFromPath(String imagePath, int width, int height)	{		Bitmap bitmap = null;		BitmapFactory.Options options = new BitmapFactory.Options();		options.inJustDecodeBounds = true;		bitmap = BitmapFactory.decodeFile(imagePath, options);		options.inJustDecodeBounds = false; 		int h = options.outHeight;		int w = options.outWidth;		int beWidth = w / width;		int beHeight = h / height;		int be = 1;		if (beWidth < beHeight)		{			be = beWidth;		} 		else		{			be = beHeight;		}		if (be <= 0)		{			be = 1;		}		options.inSampleSize = be;		bitmap = BitmapFactory.decodeFile(imagePath, options);		bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height,		ThumbnailUtils.OPTIONS_RECYCLE_INPUT);		return bitmap;	}				//以指定中心位置，等比例缩放图片到指定大小	public static Bitmap zoomBitmap(Bitmap bitmap, double w, double h)	{		Bitmap newbmp = null;		int width = bitmap.getWidth();		int height = bitmap.getHeight();		Matrix matrix = new Matrix();		float scaleWidht = ((float) w / width);		float scaleHeight = ((float) h / height);		matrix.postScale(scaleWidht, scaleHeight);		try		{			newbmp = Bitmap.createBitmap(bitmap, 0, 0, width, height,					matrix, true);					} catch (Exception e)		{			// TODO: handle exception		}				return newbmp;	}			//图像旋转	public static Bitmap convert(Bitmap a, int width, int height)	{		int w = a.getWidth();		int h = a.getHeight();		Bitmap newb = Bitmap.createBitmap(w, h, Config.ARGB_8888);// 创建一个新的和SRC长度宽度一样的位图		Canvas cv = new Canvas(newb);		Matrix m = new Matrix();//		m.postScale(1, -1);   //镜像垂直翻转//		m.postScale(-1, 1);   //镜像水平翻转		m.postRotate(-180);  //旋转-90度		Bitmap new2 = Bitmap.createBitmap(a, 0, 0, w, h, m, true);		cv.drawBitmap(new2, new Rect(0, 0, new2.getWidth(), new2.getHeight()),new Rect(0, 0, width, height), null);		return newb;	}			//图像旋转	public static Bitmap adjustPhotoRotation(Bitmap bm, final int orientationDegree)	{        Matrix m = new Matrix();        m.setRotate(orientationDegree, (float) bm.getWidth(), (float) bm.getHeight());        float targetX, targetY;        if (orientationDegree == 90)         {        targetX = bm.getHeight();        targetY = 0;        }         else         {        targetX = bm.getHeight();        targetY = bm.getWidth();        }	    final float[] values = new float[9];	    m.getValues(values);	    float x1 = values[Matrix.MTRANS_X];	    float y1 = values[Matrix.MTRANS_Y];	    m.postTranslate(targetX - x1, targetY - y1);	    Bitmap bm1 = Bitmap.createBitmap(bm.getHeight(), bm.getWidth(), Bitmap.Config.ARGB_8888);	    Paint paint = new Paint();	    Canvas canvas = new Canvas(bm1);	    canvas.drawBitmap(bm, m, paint);	    return bm1;	  }			//从原图片截取指定大小的图片	//图像像素截取	public static Bitmap cutBitmap(Bitmap bitmap, int x, int y, int width, int height)	{		return Bitmap.createBitmap(bitmap, x, y, width, height);	}						//图像形状和颜色处理	//图像形状处理		//圆角图片	public static Bitmap bitmapToRoundCorner(Bitmap bitmap, int pixels)	{		Bitmap output = Bitmap.createBitmap(bitmap.getWidth(),				bitmap.getHeight(), Config.ARGB_8888);		Canvas canvas = new Canvas(output);		final int color = 0xff424242;		final Paint paint = new Paint();		final Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());		final RectF rectF = new RectF(rect);		final float roundPx = pixels;		paint.setAntiAlias(true);		canvas.drawARGB(0, 0, 0, 0);		paint.setColor(color);		canvas.drawRoundRect(rectF, roundPx, roundPx, paint);		paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));		canvas.drawBitmap(bitmap, rect, rect, paint);		return output;	}					//转变为灰度图	//图像像素处理	//灰度图	public static Bitmap toGrayscale(Bitmap bmpOriginal)	{		int width, height;		height = bmpOriginal.getHeight();		width = bmpOriginal.getWidth();		Bitmap bmpGrayscale = Bitmap.createBitmap(width, height,				Bitmap.Config.RGB_565);		Canvas c = new Canvas(bmpGrayscale);		Paint paint = new Paint();		ColorMatrix cm = new ColorMatrix();		cm.setSaturation(0);		ColorMatrixColorFilter f = new ColorMatrixColorFilter(cm);		paint.setColorFilter(f);		c.drawBitmap(bmpOriginal, 0, 0, paint);		return bmpGrayscale;	}				//在图片指定位置加水印	//图像图像，图像文字合并	public static Bitmap watermark(Bitmap src, Bitmap mark, int x, int y)    {        int w = src.getWidth();          int h = src.getHeight();          Bitmap newb = Bitmap.createBitmap(w, h, Config.RGB_565);        Canvas cv = new Canvas(newb);           cv.drawBitmap(src, 0, 0, null);         cv.drawBitmap(mark, x, y, null);        cv.save(Canvas.ALL_SAVE_FLAG);//保存        cv.restore();//存储          return newb;    }						//图片上绘制文字	public static Bitmap drawText2Bitmap(Bitmap src, String mString, int x, int y, int size, int color) 	{  		int w = src.getWidth();          int h = src.getHeight();          Bitmap newb = Bitmap.createBitmap(w, h, Config.RGB_565);        Canvas cv = new Canvas(newb);           cv.drawBitmap(src, 0, 0, null);                   Paint p = new Paint();           p.setARGB(250, 255, 255, 255);         p.setAntiAlias(true);//去除锯齿          p.setFilterBitmap(true);//对位图进行滤波处理          p.setTextSize(size);             cv.drawText(mString, x, y, p);                   cv.save(Canvas.ALL_SAVE_FLAG);        cv.restore();          return newb;      }  			            //多个图像合并为一个文件    public static void unionMultiImages(String newPath, ArrayList<String> imageArrayList) throws Exception      {          File newFile=new File(newPath);          byte buffer[]=new byte[1024];          int readcount;          if(!newFile.getParentFile().exists())              throw new Exception("你合并的文件夹的不存在...");          FileOutputStream writer=new FileOutputStream(newPath);                  for(int i=0;i<imageArrayList.size();i++)        {        	 FileInputStream reader=new FileInputStream(imageArrayList.get(i));        	         	 int size = reader.toString().length();        	         	 while((readcount = reader.read(buffer))!=-1)               {                   writer.write(buffer, 0, readcount) ;             }          	 writer.flush();             reader.close();        }        writer.close();              }          			    //调用系统裁剪	public static void startPhotoZoom(Activity aty, Uri uri, String imagePath)	{		File f = new File(imagePath);		if (!f.exists())		{			File parentFile = f.getParentFile();			if (!parentFile.exists())			{				parentFile.mkdirs();			}			try			{				f.createNewFile();			} catch (IOException e)			{				// TODO Auto-generated catch block				e.printStackTrace();			}		}		Intent intent = new Intent("com.android.camera.action.CROP");		intent.setDataAndType(uri, "image/*");		// crop为true是设置在开启的intent中设置显示的view可以剪裁		intent.putExtra("crop", "true");		// aspectX aspectY 是宽高的比例		intent.putExtra("aspectX", 1);		intent.putExtra("aspectY", 1);		// outputX,outputY 是剪裁图片的宽高		intent.putExtra("outputX", 300);		intent.putExtra("outputY", 300);		intent.putExtra("return-data", true);		intent.putExtra("noFaceDetection", true);		intent.putExtra("output", Uri.fromFile(new File(imagePath)));// 保存到原文件		intent.putExtra("outputFormat", "JPEG");// 返回格式		aty.startActivityForResult(intent, 3);	}						//图片文件格式转换	//图像格式转换	public static byte[] readStream(InputStream inStream)	{		ByteArrayOutputStream outStream = new ByteArrayOutputStream();		byte[] buffer = new byte[1024];		int len = 0;		try		{			while ((len = inStream.read(buffer)) != -1)			{				outStream.write(buffer, 0, len);			}			outStream.close();			inStream.close();		} catch (IOException e)		{			e.printStackTrace();		}		return outStream.toByteArray();	}			public static String InputStream2String(InputStream in,String encoding) throws Exception	 {  		int BUFFER_SIZE = 4096;       ByteArrayOutputStream outStream = new ByteArrayOutputStream();         byte[] data = new byte[BUFFER_SIZE];         int count = -1;         while((count = in.read(data,0,BUFFER_SIZE)) != -1)             outStream.write(data, 0, count);                  data = null;         return new String(outStream.toByteArray(),"UTF-8"); 	 }				public static byte[] bitmap2Bytes(Bitmap bm)	{		ByteArrayOutputStream bas = new ByteArrayOutputStream();		bm.compress(Bitmap.CompressFormat.JPEG, 100, bas);		return bas.toByteArray();	}				public static Bitmap bytesToBimap(byte[] b)	{		if (b.length != 0)		{			return BitmapFactory.decodeByteArray(b, 0, b.length);		} else		{			return null;		}	}				public static Bitmap drawableToBitmapByBD(Drawable drawable)	{		BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;		return bitmapDrawable.getBitmap();	}				public static Drawable bitmapToDrawableByBD(Bitmap bitmap)	{		Drawable drawable = new BitmapDrawable(bitmap);		return drawable;	}				public static String bytesToHexString(byte[] src)	 {  	    StringBuilder stringBuilder = new StringBuilder("");  	    if (src == null || src.length <= 0) 	    {  	        return null;  	    }  	    for (int i = 0; i < src.length; i++) 	    {  	        int v = src[i] & 0xFF;  	        String hv = Integer.toHexString(v);  	        if (hv.length() < 2) 	        {  	            stringBuilder.append(0);  	        }  	        stringBuilder.append(hv);  	    }  	    return stringBuilder.toString();       } 				public static String bitmapToHexString(Bitmap bitmap)	{		String result = null;		ByteArrayOutputStream baos = null;		try		{			if (bitmap != null)			{				baos = new ByteArrayOutputStream();				bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos);				baos.flush();				baos.close();				byte[] bitmapBytes = baos.toByteArray();								result=bytesToHexString(bitmapBytes);			}		} catch (IOException e)		{			e.printStackTrace();		} finally		{			try			{				if (baos != null)				{					baos.flush();					baos.close();				}			} catch (IOException e)			{				e.printStackTrace();			}		}		return result;	}				public static String bitmapToBase64String(Bitmap bitmap)	{		String result = null;		ByteArrayOutputStream baos = null;		try		{			if (bitmap != null)			{				baos = new ByteArrayOutputStream();				bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos);				baos.flush();				baos.close();				byte[] bitmapBytes = baos.toByteArray();								result = Base64.encodeToString(bitmapBytes, Base64.DEFAULT);			}		} catch (IOException e)		{			e.printStackTrace();		} finally		{			try			{				if (baos != null)				{					baos.flush();					baos.close();				}			} catch (IOException e)			{				e.printStackTrace();			}		}		return result;	}				public static Bitmap base64StringToBitmap(String base64Data)	{		byte[] bytes = Base64.decode(base64Data, Base64.DEFAULT);		return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);	}				public static byte[] base64ToBytes(String base64Data)	{		byte[] bytes = Base64.decode(base64Data, Base64.DEFAULT);		return bytes;	}				public static String bytesToBase64(byte[] bytes)	{		return Base64.encodeToString(bytes, Base64.DEFAULT);	}		public static Bitmap resouceIdToBitmap(Context context, int resouceId)	{		Bitmap resultBitmap = null;				Drawable drawable = context.getResources().getDrawable(resouceId);		resultBitmap = drawableToBitmapByBD(drawable);				return resultBitmap;	}			}